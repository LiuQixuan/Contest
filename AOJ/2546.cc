//Name: Chocolate
//Level: 2
//Category: 動的計画法,DP
//Note:

/**
 * あるピースを食べるためには、その真上に存在するピースは必ず食べられている必要がある。
 * また、端以外のピースでは、少なくともその左右どちらかのピースが食べられている必要がある。
 *
 * これらの事実より、まず、上から順に1行ずつ食べていっても結果は変わらないことがわかる。
 * 次に、ある行を食べていくときは、両端のうち少なくとも片方は反転させずに食べる必要があることがわかる。
 * 同様の考察を繰り返すと、ある行に含まれるほとんどのピースは反転させた状態で食べることになり、反転させずに食べられるピースは以下の2通りのどちらかである。
 * (1) 両端から食べ進めていき、最後に列iのピースのみが残るようにする。
 *     このとき、両端と列iのピースが反転されていない状態で食べられる。
 * (2) 一方の端から食べ進めていき、反対側の端まで食べる。
 *     このとき、最初に選んだピースのみが反転されていない状態で食べられる。
 * したがって、各行に対して、どちらの戦略を取ったほうが得であるかを個別に判定していけばよい。
 *
 * 幅が2以下のとき、(1)の食べ方は不可能であることに注意。
 * オーダーは O(NM)。
 */
#include <iostream>
#include <string>
#include <vector>

using namespace std;

bool solve() {
    int M, N;
    if(!(cin >> M >> N)) return false;

    int score = 0;
    for(int i = 0; i < M; ++i) {
        int subsum = 0;
        int edge_1 = 0;
        int mid_1 = 0;
        for(int j = 0; j < N; ++j) {
            int p;
            cin >> p;
            if(i > 0) p ^= 1;
            subsum += p^1; // すべてのピースは反転させてから食べるとして、後で調整する
            if(j == 0 || j == N-1) edge_1 += p;
            else mid_1 += p;
        }
        // Pattern (1)
        // 端について
        // ・両端とも辛ければ-2
        // ・片方だけ甘ければ+0
        // ・両方とも甘ければ+2
        // さらに、中間で(mid_1 > 0 ? 1 : -1)だけ増える
        // （両端以外で甘いピースがない場合、わざわざ辛いピースのままで食べることになるため）
        const int s1 = score + subsum + (edge_1-1) * 2 + (mid_1 > 0 ? 1 : -1);
        // Pattern (2)
        // edge_1が0のとき、どちらかは辛いままで食べる必要があるので1だけ減る。
        // edge_1が1のとき、甘い方から食べていけば1増える。
        // edge_1が2のとき、どちらかを甘いままで食べられるので1だけ増える。
        const int s2 = score + subsum + (edge_1 > 0 ? 1 : -1);
        score = max(score, s2);
        if(N > 2) score = max(score, s1);
    }
    cout << score << endl;
    return true;
}

int main() {
    cin.tie(0);
    ios::sync_with_stdio(0);

    while(solve()) ;
    return 0;
}
